<!doctype html><html lang=zh-cn>
<head prefix="og: http://ogp.me/ns# article: http://ogp.me/ns/article#">
<meta charset=utf-8>
<meta name=generator content="Hugo 0.88.1"><meta name=theme-color content="#16171d">
<meta name=viewport content="width=device-width,initial-scale=1">
<meta name=format-detection content="telephone=no, date=no, address=no, email=no">
<meta http-equiv=cache-control content="no-transform">
<meta http-equiv=cache-control content="no-siteapp">
<title>MIT6.828 | Lab 2: Memory Management - Part 2: Virtual Memory | The Daily Awesome</title>
<link rel=stylesheet href=/css/meme.min.c7b66d8ab937ea5489e87c6d96c470e3f5e7b5a21a385e18c358b7b3be61b6de.css>
<script src=/js/meme.min.8cbe976441b5181abfd3093c9beee209b19cdbb1fa77c48d225a83ba81fa3fb1.js></script>
<link rel=preconnect href=https://fonts.gstatic.com crossorigin>
<link rel=stylesheet href="https://fonts.loli.net/css2?family=EB+Garamond:ital,wght@0,400;0,500;0,700;1,400;1,700&family=Noto+Serif+SC:wght@400;500;700&family=Source+Code+Pro:ital,wght@0,400;0,700;1,400;1,700&display=swap" media=print onload="this.media='all'">
<noscript><link rel=stylesheet href="https://fonts.loli.net/css2?family=EB+Garamond:ital,wght@0,400;0,500;0,700;1,400;1,700&family=Noto+Serif+SC:wght@400;500;700&family=Source+Code+Pro:ital,wght@0,400;0,700;1,400;1,700&display=swap"></noscript>
<meta name=author content="Jiachen Zhang"><meta name=description content="虚拟地址、线性地址和物理地址
在x86术语中，虚拟地址由 段选择器 segment selector 和段内的偏移量 offset 组成。 线性地址是您在分段翻译 segment translation 之后, 页面翻译  page translation 之前获得的。 物理地址是在段和页面翻译之后最终得到的，最终在硬件总线上抵达RAM的内容。">
<link rel="shortcut icon" href=/favicon.ico type=image/x-icon>
<link rel=mask-icon href=/icons/safari-pinned-tab.svg color=#2a6df4>
<link rel=apple-touch-icon sizes=180x180 href=/icons/apple-touch-icon.png>
<meta name=apple-mobile-web-app-capable content="yes">
<meta name=apple-mobile-web-app-title content="The Daily Awesome">
<meta name=apple-mobile-web-app-status-bar-style content="black">
<meta name=mobile-web-app-capable content="yes">
<meta name=application-name content="The Daily Awesome">
<meta name=msapplication-starturl content="../">
<meta name=msapplication-TileColor content="#fff">
<meta name=msapplication-TileImage content="../icons/mstile-150x150.png">
<link rel=manifest href=/manifest.json>
<link rel=canonical href=https://www.zhangjc.site/archives-583/>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","datePublished":"2019-06-20T01:20:00+00:00","dateModified":"2021-10-01T20:54:44+08:00","url":"https://www.zhangjc.site/archives-583/","headline":"MIT6.828 | Lab 2: Memory Management - Part 2: Virtual Memory","description":"虚拟地址、线性地址和物理地址\n在x86术语中，虚拟地址由 段选择器 segment selector 和段内的偏移量 offset 组成。 线性地址是您在分段翻译 segment translation 之后, 页面翻译  page translation 之前获得的。 物理地址是在段和页面翻译之后最终得到的，最终在硬件总线上抵达RAM的内容。","inLanguage":"zh-CN","articleSection":"tech","wordCount":4032,"image":["https://image-hosting.zhangjc.tech/ghost/content/images/2019/06/922616490.png","https://image-hosting.zhangjc.tech/ghost/content/images/2019/06/3207708407.png"],"author":{"@type":"Person","description":"The Daily Awesome","email":"zhangjc1999@gmail.com","image":"https://www.zhangjc.site/icons/apple-touch-icon.png","url":"https://www.zhangjc.site/","name":"Jiachen"},"license":"[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)","publisher":{"@type":"Organization","name":"The Daily Awesome","logo":{"@type":"ImageObject","url":"https://www.zhangjc.site/icons/apple-touch-icon.png"},"url":"https://www.zhangjc.site/"},"mainEntityOfPage":{"@type":"WebSite","@id":"https://www.zhangjc.site/"}}</script>
<meta name=twitter:card content="summary_large_image">
<meta name=twitter:site content="@JiachenZhang5">
<meta name=twitter:creator content="@JiachenZhang5">
<meta property="og:title" content="MIT6.828 | Lab 2: Memory Management - Part 2: Virtual Memory">
<meta property="og:description" content="虚拟地址、线性地址和物理地址
在x86术语中，虚拟地址由 段选择器 segment selector 和段内的偏移量 offset 组成。 线性地址是您在分段翻译 segment translation 之后, 页面翻译  page translation 之前获得的。 物理地址是在段和页面翻译之后最终得到的，最终在硬件总线上抵达RAM的内容。">
<meta property="og:url" content="https://www.zhangjc.site/archives-583/">
<meta property="og:site_name" content="The Daily Awesome">
<meta property="og:locale" content="zh"><meta property="og:image" content="https://image-hosting.zhangjc.tech/ghost/content/images/2019/06/922616490.png">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2019-06-20T01:20:00+00:00">
<meta property="article:modified_time" content="2021-10-01T20:54:44+08:00">
<meta property="article:section" content="tech">
<script type=text/javascript src="https://s4.cnzz.com/z_stat.php?id=1279769355&web_id=1279769355"></script>
</head>
<body>
<div class=container>
<header class=header>
<div class=header-wrapper>
<div class="header-inner single">
<div class=site-brand>
<a href=/ class=brand>The Daily Awesome</a>
</div>
<nav class=nav>
<ul class=menu id=menu>
<li class=menu-item><a href=/life/><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon archive"><path d="M32 448c0 17.7 14.3 32 32 32h384c17.7.0 32-14.3 32-32V160H32v288zm160-212c0-6.6 5.4-12 12-12h104c6.6.0 12 5.4 12 12v8c0 6.6-5.4 12-12 12H204c-6.6.0-12-5.4-12-12v-8zM480 32H32C14.3 32 0 46.3.0 64v48c0 8.8 7.2 16 16 16h480c8.8.0 16-7.2 16-16V64c0-17.7-14.3-32-32-32z"/></svg><span class=menu-item-name>生活</span></a>
</li>
<li class=menu-item><a href=/tech/><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon th"><path d="M149.333 56v80c0 13.255-10.745 24-24 24H24c-13.255.0-24-10.745-24-24V56c0-13.255 10.745-24 24-24h101.333c13.255.0 24 10.745 24 24zm181.334 240v-80c0-13.255-10.745-24-24-24H205.333c-13.255.0-24 10.745-24 24v80c0 13.255 10.745 24 24 24h101.333c13.256.0 24.001-10.745 24.001-24zm32-240v80c0 13.255 10.745 24 24 24H488c13.255.0 24-10.745 24-24V56c0-13.255-10.745-24-24-24H386.667c-13.255.0-24 10.745-24 24zm-32 80V56c0-13.255-10.745-24-24-24H205.333c-13.255.0-24 10.745-24 24v80c0 13.255 10.745 24 24 24h101.333c13.256.0 24.001-10.745 24.001-24zm-205.334 56H24c-13.255.0-24 10.745-24 24v80c0 13.255 10.745 24 24 24h101.333c13.255.0 24-10.745 24-24v-80c0-13.255-10.745-24-24-24zM0 376v80c0 13.255 10.745 24 24 24h101.333c13.255.0 24-10.745 24-24v-80c0-13.255-10.745-24-24-24H24c-13.255.0-24 10.745-24 24zm386.667-56H488c13.255.0 24-10.745 24-24v-80c0-13.255-10.745-24-24-24H386.667c-13.255.0-24 10.745-24 24v80c0 13.255 10.745 24 24 24zm0 160H488c13.255.0 24-10.745 24-24v-80c0-13.255-10.745-24-24-24H386.667c-13.255.0-24 10.745-24 24v80c0 13.255 10.745 24 24 24zM181.333 376v80c0 13.255 10.745 24 24 24h101.333c13.255.0 24-10.745 24-24v-80c0-13.255-10.745-24-24-24H205.333c-13.255.0-24 10.745-24 24z"/></svg><span class=menu-item-name>技术</span></a>
</li>
<li class=menu-item><a href=/about/><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512" class="icon user-circle"><path d="M248 8C111 8 0 119 0 256s111 248 248 248 248-111 248-248S385 8 248 8zm0 96c48.6.0 88 39.4 88 88s-39.4 88-88 88-88-39.4-88-88 39.4-88 88-88zm0 344c-58.7.0-111.3-26.6-146.5-68.2 18.8-35.4 55.6-59.8 98.5-59.8 2.4.0 4.8.4 7.1 1.1 13 4.2 26.6 6.9 40.9 6.9s28-2.7 40.9-6.9c2.3-.7 4.7-1.1 7.1-1.1 42.9.0 79.7 24.4 98.5 59.8C359.3 421.4 306.7 448 248 448z"/></svg><span class=menu-item-name>关于</span></a>
</li>
<li class=menu-item>
<a id=theme-switcher href=#><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon theme-icon-light"><path d="M193.2 104.5 242 7a18 18 0 0128 0l48.8 97.5L422.2 70A18 18 0 01442 89.8l-34.5 103.4L505 242a18 18 0 010 28l-97.5 48.8L442 422.2A18 18 0 01422.2 442l-103.4-34.5L270 505a18 18 0 01-28 0l-48.8-97.5L89.8 442A18 18 0 0170 422.2l34.5-103.4-97.5-48.8a18 18 0 010-28l97.5-48.8L70 89.8A18 18 0 0189.8 70zM256 128a128 128 0 10.01.0M256 160a96 96 0 10.01.0"/></svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon theme-icon-dark"><path d="M27 412A256 256 0 10181 5a11.5 11.5.0 00-5 20A201.5 201.5.0 0142 399a11.5 11.5.0 00-15 13"/></svg></a>
</li>
</ul>
</nav>
</div>
</div>
<input type=checkbox id=nav-toggle aria-hidden=true>
<label for=nav-toggle class=nav-toggle></label>
<label for=nav-toggle class=nav-curtain></label>
</header>
<main class="main single" id=main>
<div class=main-inner>
<article class="content post h-entry" data-align=justify data-type=tech data-toc-num=true>
<h1 class="post-title p-name">MIT6.828 | Lab 2: Memory Management - Part 2: Virtual Memory</h1>
<div class=post-meta>
<time datetime=2019-06-20T01:20:00+00:00 class="post-meta-item published dt-published"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" class="icon post-meta-icon"><path d="M148 288h-40c-6.6.0-12-5.4-12-12v-40c0-6.6 5.4-12 12-12h40c6.6.0 12 5.4 12 12v40c0 6.6-5.4 12-12 12zm108-12v-40c0-6.6-5.4-12-12-12h-40c-6.6.0-12 5.4-12 12v40c0 6.6 5.4 12 12 12h40c6.6.0 12-5.4 12-12zm96 0v-40c0-6.6-5.4-12-12-12h-40c-6.6.0-12 5.4-12 12v40c0 6.6 5.4 12 12 12h40c6.6.0 12-5.4 12-12zm-96 96v-40c0-6.6-5.4-12-12-12h-40c-6.6.0-12 5.4-12 12v40c0 6.6 5.4 12 12 12h40c6.6.0 12-5.4 12-12zm-96 0v-40c0-6.6-5.4-12-12-12h-40c-6.6.0-12 5.4-12 12v40c0 6.6 5.4 12 12 12h40c6.6.0 12-5.4 12-12zm192 0v-40c0-6.6-5.4-12-12-12h-40c-6.6.0-12 5.4-12 12v40c0 6.6 5.4 12 12 12h40c6.6.0 12-5.4 12-12zm96-260v352c0 26.5-21.5 48-48 48H48c-26.5.0-48-21.5-48-48V112c0-26.5 21.5-48 48-48h48V12c0-6.6 5.4-12 12-12h40c6.6.0 12 5.4 12 12v52h128V12c0-6.6 5.4-12 12-12h40c6.6.0 12 5.4 12 12v52h48c26.5.0 48 21.5 48 48zm-48 346V160H48v298c0 3.3 2.7 6 6 6h340c3.3.0 6-2.7 6-6z"/></svg>&nbsp;2019.6.20</time>
<span class="post-meta-item category"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon post-meta-icon"><path d="M464 128H272l-54.63-54.63c-6-6-14.14-9.37-22.63-9.37H48C21.49 64 0 85.49.0 112v288c0 26.51 21.49 48 48 48h416c26.51.0 48-21.49 48-48V176c0-26.51-21.49-48-48-48zm0 272H48V112h140.12l54.63 54.63c6 6 14.14 9.37 22.63 9.37H464v224z"/></svg>&nbsp;<a href=/tech/ class="category-link p-category">Tech</a></span>
</div>
<nav class=contents>
<ol class=toc>
<li><a id=contents:虚拟地址线性地址和物理地址 href=#虚拟地址线性地址和物理地址>虚拟地址、线性地址和物理地址</a></li>
<li><a id=contents:引用计数 href=#引用计数>引用计数</a></li>
<li><a id=contents:页表管理 href=#页表管理>页表管理</a></li>
<li><a id=contents:pgdir_walk href=#pgdir_walk><code>pgdir_walk()</code></a></li>
<li><a id=contents:boot_map_region href=#boot_map_region><code>boot_map_region()</code></a></li>
<li><a id=contents:page_lookup href=#page_lookup><code>page_lookup()</code></a></li>
<li><a id=contents:page_remove href=#page_remove><code>page_remove()</code></a></li>
<li><a id=contents:page_insert href=#page_insert><code>page_insert()</code></a></li>
</ol>
</nav><div class="post-body e-content">
<p>首先回顾 <code>x86</code> 的保护模式内存管理架构，即 分段和页面转换 <code>segmentation translation</code> and <code>page translation</code>.</p>
<p><strong>Exercise 2.</strong> Look at chapters 5 and 6 of the <a href=https://pdos.csail.mit.edu/6.828/2018/readings/i386/toc.htm target=_blank rel=noopener>Intel 80386 Reference Manual</a>, if you haven't done so already. Read the sections about page translation and page-based protection closely (5.2 and 6.4). We recommend that you also skim the sections about segmentation; while JOS uses the paging hardware for virtual memory and protection, segment translation and segment-based protection cannot be disabled on the x86, so you will need a basic understanding of it.</p>
<p>[post cid="574" /]</p>
<p>[post cid="582" /]</p>
<h2 id=虚拟地址线性地址和物理地址><a href=#虚拟地址线性地址和物理地址 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:虚拟地址线性地址和物理地址 class=headings>虚拟地址、线性地址和物理地址</a></h2>
<p>在x86术语中，<strong>虚拟地址</strong>由 段选择器 <code>segment selector</code> 和段内的偏移量 <code>offset</code> 组成。 <strong>线性地址</strong>是您在分段翻译 <code>segment translation</code> 之后, 页面翻译 <code>page translation</code> 之前获得的。 <strong>物理地址</strong>是在段和页面翻译之后最终得到的，最终在硬件总线上抵达RAM的内容。</p>
<pre tabindex=0><code>     选择器 Selector  +--------------+         +-----------+
          ----------&gt;|              |         |           |
                     | Segmentation |         |  Paging   |
Software             |              |--------&gt;|           |----------&gt;  RAM
     偏移量  Offset   |  Mechanism   |         | Mechanism |
          ----------&gt;|              |         |           |
                     +--------------+         +-----------+
            Virtual                   Linear                Physical

</code></pre><p>C 指针是虚拟地址的偏移部分。在 <code>boot/boot.S</code>中，引入全局描述符表(GDT)将所有段基址设为0到 0xffffffff。因此线性地址等于虚拟地址的偏移量。 因此“选择器”没有效果，即线性地址总是等于虚拟地址的偏移量。 在lab3中，我们将需要与分段进行更多交互以设置权限级别，但对于内存转换，我们可以忽略整个JOS实验室中的分段，并仅关注页面转换。</p>
<p>回想实验1的第3部分，我们安装了一个简单的页表，以便内核可以在其链接地址0xf0100000上运行，即使它实际上是在ROM的BIOS上方的地址为0x00100000的物理内存中加载的。 此页表仅映射了4MB内存。 在本实验中您要为JOS设置的虚拟地址空间布局中，我们将展开它以映射从虚拟地址0xf0000000开始的第一个256MB物理内存，并映射虚拟地址空间的许多其他区域。</p>
<p><strong>Exercise 3.</strong> While GDB can only access QEMU's memory by virtual address, it's often useful to be able to inspect physical memory while setting up virtual memory. Review the QEMU <a href=https://pdos.csail.mit.edu/6.828/2018/labguide.html#qemu target=_blank rel=noopener>monitor commands</a> from the lab tools guide, especially the <code>xp</code> command, which lets you inspect physical memory. To access the QEMU monitor, press Ctrl-a c in the terminal (the same binding returns to the serial console).</p>
<p>Use the xp command in the QEMU monitor and the x command in GDB to inspect memory at corresponding physical and virtual addresses and make sure you see the same data.</p>
<p>Our patched version of QEMU provides an info pg command that may also prove useful: it shows a compact but detailed representation of the current page tables, including all mapped memory ranges, permissions, and flags. Stock QEMU also provides an info mem command that shows an overview of which ranges of virtual addresses are mapped and with what permissions.</p>
<p>x> 没有图像化界面，给出的方法没能打开monitor</p>
<p>从CPU上执行的代码开始，只要我们处于保护模式（我们在boot / boot.S 中首先设置过），就无法直接使用线性或物理地址。 所有内存引用都被解释为虚拟地址并由MMU转换，这意味着C中的所有指针都是虚拟地址。</p>
<p>JOS内核通常需要将地址操作为不透明值或整数，而不需要对它们进行引用解析(<code>dereference</code>)，例如在物理内存分配器中。 有时这些是虚拟地址，有时它们是物理地址。 为了帮助记录代码，JOS源区分了两种情况：类型<code>uintptr_t</code>表示不透明的虚拟地址，<code>physaddr_t</code>表示物理地址。 这两种类型实际上只是32位整数（<code>uint32_t</code>）的同义词，因此编译器不会阻止您将一种类型分配给另一种类型！ 由于它们是整数类型（不是指针），因此不能对他们进行引用解析。</p>
<p>JOS内核可以通过首先将其转换为指针类型来对<code>uintptr_t</code>引用解析。 但由于<code>MMU</code>会转换所有内存引用，内核不能明智地引用解析物理地址。 如果将<code>physaddr_t</code>转换为指针并引用解析，您可以加载并存储到结果地址（硬件会将其解释为虚拟地址），但您可能无法获得预期的内存位置。</p>
<p>总结：</p>
<p>C typeAddress type<code>T*</code>Virtual<code>uintptr_t</code>Virtual<code>physaddr_t</code>Physical</p>
<p><strong>Question</strong></p>
<ol>
<li>Assuming that the following JOS kernel code is correct, what type should variable <code>x</code> have, <code>uintptr_t</code> or <code>physaddr_t</code> ？</li>
</ol>
<div class=highlight><div class=chroma>
<div class=table-container><table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-c data-lang=c>	<span class=n>mystery_t</span> <span class=n>x</span><span class=p>;</span>
	<span class=kt>char</span><span class=o>*</span> <span class=n>value</span> <span class=o>=</span> <span class=n>return_a_pointer</span><span class=p>();</span>
	<span class=o>*</span><span class=n>value</span> <span class=o>=</span> <span class=mi>10</span><span class=p>;</span>
	<span class=n>x</span> <span class=o>=</span> <span class=p>(</span><span class=n>mystery_t</span><span class=p>)</span> <span class=n>value</span><span class=p>;</span>

</code></pre></td></tr></table></div>
</div>
</div><p>value是一个指针，并且执行了 <code>deference</code>，此时载入<code>x</code>的应为虚拟地址，因此其类型应为 <code>uintptr_t</code> 。</p>
<p>JOS内核有时需要读取或修改仅了解物理地址的内存。 例如，向页表添加映射可能需要分配物理内存来存储页目录，然后初始化该内存。 然而内核无法绕过虚拟地址转换，因此无法直接加载和存储到物理地址。 JOS重新映射在虚拟地址0xf0000000，即从物理地址0开始所有物理内存的一个原因是帮助内核读写它只知道物理地址的内存。 为了将物理地址转换为内核实际可以读写的虚拟地址，内核必须将0xf0000000添加到物理地址，以在重映射区域中找到其对应的虚拟地址。 您应该使用KADDR（pa）进行加法。</p>
<p>在给定存储内核数据结构被存储的虚拟地址的情况下，JOS内核有时也需要能够找到物理地址。 由boot_alloc（）分配的内核全局变量和内存位于从0xf0000000开始的加载内核的区域，这也是我们映射所有物理内存的区域。 因此，要将此区域中的虚拟地址转换为物理地址，内核可以简单地减去0xf0000000。 您应该使用PADDR（va）进行减法。</p>
<h2 id=引用计数><a href=#引用计数 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:引用计数 class=headings>引用计数</a></h2>
<p>Reference counting</p>
<p>在之后的lab中，通常会同时在多个虚拟地址（或多个环境的地址空间）中映射相同的物理页面。 您将在与物理页面对应的<code>struct PageInfo</code>的<code>pp_ref</code>字段中保留对每个物理页面的引用数量的计数。 当物理页面的此计数变为零时，可以释放该页面，因为它不再使用。 一般来说，这个计数应该等于物理页面在所有页面表中出现在<code>UTOP</code>下面的次数（<code>UTOP</code>上面的映射主要是在内核启动时设置的，不应该被释放，因此不需要引用 算他们）。 我们还将使用它来跟踪我们保留到页面目录页面的指针数量，进而跟踪页面目录对页面表页面的引用数量。</p>
<p>使用<code>page_alloc</code>时要注意，它返回的页面的引用计数始终为0，因此只要您对返回的页面执行某些操作（例如将其插入页面表），<code>pp_ref</code>就应该递增。 有时这是由其他函数处理的（例如，page_insert），有时调用<code>page_alloc</code>的函数必须直接执行。</p>
<h2 id=页表管理><a href=#页表管理 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:页表管理 class=headings>页表管理</a></h2>
<p>Page Table Management</p>
<p>现在，编写一组用于管理页表的方法：插入和删除线性到物理映射，以及在需要时创建页表的页面。</p>
<p><strong>Exercise 4.</strong> In the file <code>kern/pmap.c</code>, you must implement code for the following functions.</p>
<div class=highlight><div class=chroma>
<div class=table-container><table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-c data-lang=c>        <span class=n>pgdir_walk</span><span class=p>()</span>
        <span class=n>boot_map_region</span><span class=p>()</span>
        <span class=n>page_lookup</span><span class=p>()</span>
        <span class=n>page_remove</span><span class=p>()</span>
        <span class=n>page_insert</span><span class=p>()</span>

</code></pre></td></tr></table></div>
</div>
</div><p><code>check_page()</code>, called from <code>mem_init()</code>, tests your page table management routines. You should make sure it reports success before proceeding.</p>
<h2 id=pgdir_walk><a href=#pgdir_walk class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:pgdir_walk class=headings><code>pgdir_walk()</code></a></h2>
<p>该函数的作用是获得指向线性地址页表项的指针</p>
<figure><img src=https://image-hosting.zhangjc.tech/ghost/content/images/2019/06/922616490.png>
</figure>
<figure><img src=https://image-hosting.zhangjc.tech/ghost/content/images/2019/06/3207708407.png>
</figure>
<div class=highlight><div class=chroma>
<div class=table-container><table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=c1>// Given &#39;pgdir&#39;, a pointer to a page directory, pgdir_walk returns
</span><span class=c1>// a pointer to the page table entry (PTE) for linear address &#39;va&#39;.
</span><span class=c1>// This requires walking the two-level page table structure.
</span><span class=c1>//
</span><span class=c1>// The relevant page table page might not exist yet.
</span><span class=c1>// If this is true, and create == false, then pgdir_walk returns NULL.
</span><span class=c1>// Otherwise, pgdir_walk allocates a new page table page with page_alloc.
</span><span class=c1>//    - If the allocation fails, pgdir_walk returns NULL.
</span><span class=c1>//    - Otherwise, the new page&#39;s reference count is incremented,
</span><span class=c1>//	the page is cleared,
</span><span class=c1>//	and pgdir_walk returns a pointer into the new page table page.
</span><span class=c1>//
</span><span class=c1>// Hint 1: you can turn a PageInfo * into the physical address of the
</span><span class=c1>// page it refers to with page2pa() from kern/pmap.h.
</span><span class=c1>//
</span><span class=c1>// Hint 2: the x86 MMU checks permission bits in both the page directory
</span><span class=c1>// and the page table, so it&#39;s safe to leave permissions in the page
</span><span class=c1>// directory more permissive than strictly necessary.
</span><span class=c1>//
</span><span class=c1>// Hint 3: look at inc/mmu.h for useful macros that manipulate page
</span><span class=c1>// table and page directory entries.
</span><span class=c1>//
</span><span class=c1></span><span class=n>pte_t</span> <span class=o>*</span>
<span class=nf>pgdir_walk</span><span class=p>(</span><span class=n>pde_t</span> <span class=o>*</span><span class=n>pgdir</span><span class=p>,</span> <span class=k>const</span> <span class=kt>void</span> <span class=o>*</span><span class=n>va</span><span class=p>,</span> <span class=kt>int</span> <span class=n>create</span><span class=p>)</span>
<span class=p>{</span>
	<span class=c1>// PDX: page directory index from linear address
</span><span class=c1></span>	<span class=kt>uint32_t</span> <span class=n>pd_idx</span> <span class=o>=</span> <span class=n>PDX</span><span class=p>(</span><span class=n>va</span><span class=p>);</span>
	<span class=c1>// PTE_P: Present bit
</span><span class=c1></span>	<span class=k>if</span> <span class=p>(</span><span class=o>~</span><span class=p>(</span><span class=n>pgdir</span><span class=p>[</span><span class=n>pd_idx</span><span class=p>]</span> <span class=o>&amp;</span> <span class=n>PTE_P</span><span class=p>))</span> <span class=p>{</span>
		<span class=c1>// The relevant page table page is not exist
</span><span class=c1></span>		<span class=k>if</span> <span class=p>(</span><span class=o>~</span><span class=n>create</span><span class=p>)</span> <span class=p>{</span>
			<span class=k>return</span> <span class=nb>NULL</span><span class=p>;</span>
		<span class=p>}</span>
		<span class=c1>// Allocates a new page table page
</span><span class=c1></span>		<span class=k>struct</span> <span class=n>PageInfo</span> <span class=o>*</span><span class=n>pg</span> <span class=o>=</span> <span class=n>page_alloc</span><span class=p>(</span><span class=n>ALLOC_ZERO</span><span class=p>);</span>
		<span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>pg</span><span class=p>)</span> <span class=k>return</span> <span class=nb>NULL</span><span class=p>;</span> <span class=c1>// the allocation fails
</span><span class=c1></span>		<span class=c1>// Clear the new page
</span><span class=c1></span>		<span class=c1>// page2kva: physical -&gt; virtual address
</span><span class=c1></span>		<span class=n>memset</span><span class=p>(</span><span class=n>page2kva</span><span class=p>(</span><span class=n>pg</span><span class=p>),</span> <span class=mi>0</span><span class=p>,</span> <span class=n>PGSIZE</span><span class=p>);</span>
		<span class=c1>// Update the reference counting manually
</span><span class=c1></span>		<span class=n>pg</span><span class=o>-&gt;</span><span class=n>pp_ref</span><span class=o>++</span><span class=p>;</span>
		<span class=c1>// page2pa(pg) | PTE_P | PTE_U | PTE_W;	
</span><span class=c1></span>		<span class=n>pgdir</span><span class=p>[</span><span class=n>pd_idx</span><span class=p>]</span> <span class=o>=</span> <span class=n>page2pa</span><span class=p>(</span><span class=n>pg</span><span class=p>)</span> <span class=o>|</span> <span class=n>PTE_P</span> <span class=o>|</span> <span class=n>PTE_U</span> <span class=o>|</span> <span class=n>PTE_W</span><span class=p>;</span>
	<span class=p>}</span>
	<span class=c1>// PTX: page table index from linear address
</span><span class=c1></span>	<span class=kt>uint32_t</span> <span class=n>pt_idx</span> <span class=o>=</span> <span class=n>PTX</span><span class=p>(</span><span class=n>va</span><span class=p>);</span>
	<span class=c1>// KADDR: physical address -&gt; virtual address
</span><span class=c1></span>	<span class=n>pte_t</span> <span class=o>*</span><span class=n>p</span> <span class=o>=</span> <span class=n>KADDR</span><span class=p>(</span><span class=n>PTE_ADDR</span><span class=p>(</span><span class=n>pgdir</span><span class=p>[</span><span class=n>pd_idx</span><span class=p>]))</span> <span class=o>+</span> <span class=n>pt_idx</span><span class=p>;</span>
	<span class=k>return</span> <span class=n>p</span><span class=p>;</span>
<span class=p>}</span>

</code></pre></td></tr></table></div>
</div>
</div><h2 id=boot_map_region><a href=#boot_map_region class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:boot_map_region class=headings><code>boot_map_region()</code></a></h2>
<p>将虚拟地址 <code>[va, va+size)</code> 映射到物理地址 <code>[pa, pa+size)</code></p>
<p>注释中提到可以使用上面写的 <code>pgdir_walk</code> ，获取页表地址，接着将物理地址的值与上权限位赋给页表地址</p>
<p>需要注意这里是 静态映射，不改变 <code>reference counting</code>。</p>
<p>关键点是理解 <code>*page table entry</code> 结果是对应的物理地址。</p>
<div class=highlight><div class=chroma>
<div class=table-container><table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=c1>//
</span><span class=c1>// Map [va, va+size) of virtual address space to physical [pa, pa+size)
</span><span class=c1>// in the page table rooted at pgdir.  Size is a multiple of PGSIZE, and
</span><span class=c1>// va and pa are both page-aligned.
</span><span class=c1>// Use permission bits perm|PTE_P for the entries.
</span><span class=c1>//
</span><span class=c1>// This function is only intended to set up the ``static&#39;&#39; mappings
</span><span class=c1>// above UTOP. As such, it should *not* change the pp_ref field on the
</span><span class=c1>// mapped pages.
</span><span class=c1>//
</span><span class=c1>// Hint: the TA solution uses pgdir_walk
</span><span class=c1></span><span class=k>static</span> <span class=kt>void</span>
<span class=nf>boot_map_region</span><span class=p>(</span><span class=n>pde_t</span> <span class=o>*</span><span class=n>pgdir</span><span class=p>,</span> <span class=n>uintptr_t</span> <span class=n>va</span><span class=p>,</span> <span class=n>size_t</span> <span class=n>size</span><span class=p>,</span> <span class=n>physaddr_t</span> <span class=n>pa</span><span class=p>,</span> <span class=kt>int</span> <span class=n>perm</span><span class=p>)</span>
<span class=p>{</span>
	<span class=c1>// Fill this function in
</span><span class=c1></span>	<span class=n>pte_t</span> <span class=o>*</span><span class=n>pt</span><span class=p>;</span>
	<span class=kt>uint32_t</span> <span class=n>offset</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
	<span class=k>while</span> <span class=p>(</span><span class=n>offset</span> <span class=o>&lt;</span> <span class=n>size</span><span class=p>)</span> <span class=p>{</span>
		<span class=c1>// Pointer to the page table entry (PTE) for linear address &#39;va&#39;
</span><span class=c1></span>		<span class=n>pt</span> <span class=o>=</span> <span class=n>pgdir_walk</span><span class=p>(</span><span class=n>pgdir</span><span class=p>,</span> <span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=p>)</span><span class=n>va</span><span class=p>,</span> <span class=mi>1</span><span class=p>);</span>
		<span class=c1>// Use permission bits perm|PTE_P for the entries.
</span><span class=c1></span>		<span class=o>*</span><span class=n>pt</span> <span class=o>=</span> <span class=n>pa</span> <span class=o>|</span> <span class=n>perm</span> <span class=o>|</span> <span class=n>PTE_P</span><span class=p>;</span>
		<span class=c1>// va and pa are both page-aligned
</span><span class=c1></span>		<span class=n>pa</span> <span class=o>+=</span> <span class=n>PGSIZE</span><span class=p>;</span>
		<span class=n>va</span> <span class=o>+=</span> <span class=n>PGSIZE</span><span class=p>;</span>
		<span class=c1>// Size is a multiple of PGSIZE
</span><span class=c1></span>		<span class=n>offset</span> <span class=o>+=</span> <span class=n>PGSIZE</span><span class=p>;</span>
	<span class=p>}</span>
<span class=p>}</span>

</code></pre></td></tr></table></div>
</div>
</div><h2 id=page_lookup><a href=#page_lookup class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:page_lookup class=headings><code>page_lookup()</code></a></h2>
<p>根据提示，<code>pgdir_walk</code> 可以获取对应的页表条目指针；<code>pa2page</code> 可以将 页表地址转换为页表。</p>
<div class=highlight><div class=chroma>
<div class=table-container><table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=c1>//
</span><span class=c1>// Return the page mapped at virtual address &#39;va&#39;.
</span><span class=c1>// If pte_store is not zero, then we store in it the address
</span><span class=c1>// of the pte for this page.  This is used by page_remove and
</span><span class=c1>// can be used to verify page permissions for syscall arguments,
</span><span class=c1>// but should not be used by most callers.
</span><span class=c1>//
</span><span class=c1>// Return NULL if there is no page mapped at va.
</span><span class=c1>//
</span><span class=c1>// Hint: the TA solution uses pgdir_walk and pa2page.
</span><span class=c1>//
</span><span class=c1></span><span class=k>struct</span> <span class=n>PageInfo</span> <span class=o>*</span>
<span class=nf>page_lookup</span><span class=p>(</span><span class=n>pde_t</span> <span class=o>*</span><span class=n>pgdir</span><span class=p>,</span> <span class=kt>void</span> <span class=o>*</span><span class=n>va</span><span class=p>,</span> <span class=n>pte_t</span> <span class=o>**</span><span class=n>pte_store</span><span class=p>)</span>
<span class=p>{</span>
	<span class=c1>// Fill this function in
</span><span class=c1></span>	<span class=c1>// Address to the page table entry (PTE) for linear address &#39;va&#39;
</span><span class=c1></span>	<span class=n>pte_t</span> <span class=o>*</span><span class=n>pte</span> <span class=o>=</span> <span class=n>pgdir_walk</span><span class=p>(</span><span class=n>pgdir</span><span class=p>,</span> <span class=n>va</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
	<span class=c1>// used by page_remove
</span><span class=c1></span>	<span class=k>if</span> <span class=p>(</span><span class=n>pte_store</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
		<span class=c1>// Store in it the address of the pte for this page
</span><span class=c1></span>		<span class=o>*</span><span class=n>pte_store</span> <span class=o>=</span> <span class=n>pte</span><span class=p>;</span>
	<span class=p>}</span>
	<span class=c1>// check if there is any page mapped at va
</span><span class=c1></span>	<span class=k>if</span> <span class=p>(</span><span class=n>pte</span> <span class=o>!=</span> <span class=nb>NULL</span> <span class=o>&amp;&amp;</span> <span class=p>(</span><span class=o>*</span><span class=n>pte</span> <span class=o>&amp;</span> <span class=n>PTE_P</span><span class=p>))</span> <span class=p>{</span>
		<span class=c1>// PTE_ADDR: address in page table or page directory entry
</span><span class=c1></span>		<span class=k>return</span> <span class=n>pa2page</span><span class=p>(</span><span class=n>PTE_ADDR</span><span class=p>(</span><span class=o>*</span><span class=n>pte</span><span class=p>));</span>
	<span class=p>}</span>
	<span class=k>return</span> <span class=nb>NULL</span><span class=p>;</span>
<span class=p>}</span>

</code></pre></td></tr></table></div>
</div>
</div><h2 id=page_remove><a href=#page_remove class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:page_remove class=headings><code>page_remove()</code></a></h2>
<p>取消虚拟地址 <code>va</code> 的映射，包含以下操作：</p>
<ul>
<li><code>reference count</code> 减少</li>
<li>如果<code>reference count</code> 减至0，需要释放物理页面</li>
<li>对应 <code>va</code> 的页表条目应被置为0（如果存在）</li>
<li>如果从页表中移除了条目，则 <code>TLB</code> 应失效</li>
</ul>
<div class=highlight><div class=chroma>
<div class=table-container><table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=c1>//
</span><span class=c1>// Unmaps the physical page at virtual address &#39;va&#39;.
</span><span class=c1>// If there is no physical page at that address, silently does nothing.
</span><span class=c1>//
</span><span class=c1>// Details:
</span><span class=c1>//   - The ref count on the physical page should decrement.
</span><span class=c1>//   - The physical page should be freed if the refcount reaches 0.
</span><span class=c1>//   - The pg table entry corresponding to &#39;va&#39; should be set to 0.
</span><span class=c1>//     (if such a PTE exists)
</span><span class=c1>//   - The TLB must be invalidated if you remove an entry from
</span><span class=c1>//     the page table.
</span><span class=c1>//
</span><span class=c1>// Hint: The TA solution is implemented using page_lookup,
</span><span class=c1>// 	tlb_invalidate, and page_decref.
</span><span class=c1>//
</span><span class=c1></span><span class=kt>void</span>
<span class=nf>page_remove</span><span class=p>(</span><span class=n>pde_t</span> <span class=o>*</span><span class=n>pgdir</span><span class=p>,</span> <span class=kt>void</span> <span class=o>*</span><span class=n>va</span><span class=p>)</span>
<span class=p>{</span>
	<span class=c1>// Fill this function in
</span><span class=c1></span>	<span class=n>pte_t</span> <span class=o>*</span><span class=n>pte</span><span class=p>;</span>
	<span class=c1>// the page mapped at virtual address &#39;va&#39;
</span><span class=c1></span>	<span class=k>struct</span> <span class=n>PageInfo</span> <span class=o>*</span><span class=n>page</span> <span class=o>=</span> <span class=n>page_lookup</span><span class=p>(</span><span class=n>pgdir</span><span class=p>,</span> <span class=n>va</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>pte</span><span class=p>);</span>
	<span class=k>if</span> <span class=p>(</span><span class=n>page</span><span class=p>)</span> <span class=p>{</span>
		<span class=c1>// decrese the ref and auto free physical page if ref == 0
</span><span class=c1></span>		<span class=n>page_decref</span><span class=p>(</span><span class=n>page</span><span class=p>);</span>
		<span class=c1>// set the pg table entry corresponding to &#39;va&#39; to 0
</span><span class=c1></span>		<span class=o>*</span><span class=n>pte</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
		<span class=c1>// Invalidate a TLB entry
</span><span class=c1></span>		<span class=n>tlb_invalidate</span><span class=p>(</span><span class=n>pgdir</span><span class=p>,</span> <span class=n>va</span><span class=p>);</span>
	<span class=p>}</span>
<span class=p>}</span>

</code></pre></td></tr></table></div>
</div>
</div><h2 id=page_insert><a href=#page_insert class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:page_insert class=headings><code>page_insert()</code></a></h2>
<p>完成物理页面<code>pp</code> 和虚拟地址 <code>va</code> 之间的映射，将页表条目的低12bit设置为 <code>perm|PTEE_P</code></p>
<div class=highlight><div class=chroma>
<div class=table-container><table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span><span class=lnt>57
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=c1>//
</span><span class=c1>// Map the physical page &#39;pp&#39; at virtual address &#39;va&#39;.
</span><span class=c1>// The permissions (the low 12 bits) of the page table entry
</span><span class=c1>// should be set to &#39;perm|PTE_P&#39;.
</span><span class=c1>//
</span><span class=c1>// Requirements
</span><span class=c1>//   - If there is already a page mapped at &#39;va&#39;, it should be page_remove()d.
</span><span class=c1>//   - If necessary, on demand, a page table should be allocated and inserted
</span><span class=c1>//     into &#39;pgdir&#39;.
</span><span class=c1>//   - pp-&gt;pp_ref should be incremented if the insertion succeeds.
</span><span class=c1>//   - The TLB must be invalidated if a page was formerly present at &#39;va&#39;.
</span><span class=c1>//
</span><span class=c1>// Corner-case hint: Make sure to consider what happens when the same
</span><span class=c1>// pp is re-inserted at the same virtual address in the same pgdir.
</span><span class=c1>// However, try not to distinguish this case in your code, as this
</span><span class=c1>// frequently leads to subtle bugs; there&#39;s an elegant way to handle
</span><span class=c1>// everything in one code path.
</span><span class=c1>//
</span><span class=c1>// RETURNS:
</span><span class=c1>//   0 on success
</span><span class=c1>//   -E_NO_MEM, if page table couldn&#39;t be allocated
</span><span class=c1>//
</span><span class=c1>// Hint: The TA solution is implemented using pgdir_walk, page_remove,
</span><span class=c1>// and page2pa.
</span><span class=c1>//
</span><span class=c1></span><span class=kt>int</span>
<span class=nf>page_insert</span><span class=p>(</span><span class=n>pde_t</span> <span class=o>*</span><span class=n>pgdir</span><span class=p>,</span> <span class=k>struct</span> <span class=n>PageInfo</span> <span class=o>*</span><span class=n>pp</span><span class=p>,</span> <span class=kt>void</span> <span class=o>*</span><span class=n>va</span><span class=p>,</span> <span class=kt>int</span> <span class=n>perm</span><span class=p>)</span>
<span class=p>{</span>
	<span class=c1>// Fill this function in
</span><span class=c1></span>	<span class=c1>// Address of the page table entry (PTE) for linear address &#39;va&#39;
</span><span class=c1></span>	<span class=c1>// create on demond, a page table should be allocated and inserted into &#39;pgdir&#39;.
</span><span class=c1></span>	<span class=n>pte_t</span> <span class=o>*</span><span class=n>pte</span> <span class=o>=</span> <span class=n>pgdir_walk</span><span class=p>(</span><span class=n>pgdir</span><span class=p>,</span> <span class=n>va</span><span class=p>,</span> <span class=mi>1</span><span class=p>);</span>	
	<span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>pte</span><span class=p>)</span> <span class=p>{</span>	<span class=c1>// page table couldn&#39;t be allocated
</span><span class=c1></span>		<span class=k>return</span> <span class=o>-</span><span class=n>E_NO_MEM</span><span class=p>;</span>
	<span class=p>}</span>
	<span class=k>if</span> <span class=p>(</span><span class=o>*</span><span class=n>pte</span> <span class=o>&amp;</span> <span class=n>PTE_P</span><span class=p>)</span> <span class=p>{</span>	<span class=c1>// the *pte is validate
</span><span class=c1></span>		<span class=c1>// PTE_ADDR: Address in page table or page directory entry
</span><span class=c1></span>		<span class=c1>// page2pa: physical -&gt; virtual
</span><span class=c1></span>		<span class=k>if</span> <span class=p>(</span><span class=n>PTE_ADDR</span><span class=p>(</span><span class=o>*</span><span class=n>pte</span><span class=p>)</span> <span class=o>==</span> <span class=n>page2pa</span><span class=p>(</span><span class=n>pp</span><span class=p>))</span> <span class=p>{</span>
			<span class=c1>// The TLB must be invalidated if a page was formerly present at &#39;va&#39;
</span><span class=c1></span>			<span class=n>tlb_invalidate</span><span class=p>(</span><span class=n>pgdir</span><span class=p>,</span> <span class=n>va</span><span class=p>);</span>
			<span class=c1>// do not use page_decref(), as physical may be free
</span><span class=c1></span>			<span class=n>pp</span><span class=o>-&gt;</span><span class=n>pp_ref</span><span class=o>--</span><span class=p>;</span>	
		<span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
			<span class=c1>// already a page mapped at &#39;va&#39;, it should be page_remove()
</span><span class=c1></span>			<span class=n>page_remove</span><span class=p>(</span><span class=n>pgdir</span><span class=p>,</span> <span class=n>va</span><span class=p>);</span>
		<span class=p>}</span>
	<span class=p>}</span>
	<span class=o>*</span><span class=n>pte</span> <span class=o>=</span> <span class=n>page2pa</span><span class=p>(</span><span class=n>pp</span><span class=p>)</span> <span class=o>|</span> <span class=n>perm</span> <span class=o>|</span> <span class=n>PTE_P</span><span class=p>;</span>
	<span class=c1>// pp-&gt;pp_ref should be incremented if the insertion succeeds.
</span><span class=c1></span>	<span class=n>pp</span><span class=o>-&gt;</span><span class=n>pp_ref</span><span class=o>++</span><span class=p>;</span>
	<span class=c1>// The permissions (the low 12 bits) of the page table entry should be set to &#39;perm|PTE_P&#39;.
</span><span class=c1></span>	<span class=c1>// PDX: page directory index from linear address
</span><span class=c1></span>	<span class=o>*</span><span class=n>pte</span> <span class=o>=</span> <span class=n>page2pa</span><span class=p>(</span><span class=n>pp</span><span class=p>)</span> <span class=o>|</span> <span class=n>perm</span> <span class=o>|</span> <span class=n>PTE_P</span><span class=p>;</span>
	<span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
<span class=p>}</span>

</code></pre></td></tr></table></div>
</div>
</div><p>编译后运行，可以看到测试通过</p>
<div class=highlight><div class=chroma>
<div class=table-container><table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>qemu-system-i386 -nographic -drive <span class=nv>file</span><span class=o>=</span>obj/kern/kernel.img,index<span class=o>=</span>0,media<span class=o>=</span>disk,format<span class=o>=</span>raw -serial mon:stdio -gdb 
tcp::26000 -D qemu.log
<span class=m>6828</span> decimal is  octal! 
Physical memory: 131072K available, <span class=nv>base</span> <span class=o>=</span> 640K, <span class=nv>extended</span> <span class=o>=</span> 130432K
boot_alloc memory at &lt;f011a000&gt;
Next free memory at &lt;f011b000&gt;
boot_alloc memory at &lt;f011b000&gt;
Next free memory at &lt;f015b000&gt; 
kern end page:347
check_page_free_list<span class=o>()</span> succeeded!
check_page_alloc<span class=o>()</span> succeeded! 
check_page<span class=o>()</span> succeeded!
check_kern_pgdir<span class=o>()</span> succeeded! 
check_page_free_list<span class=o>()</span> succeeded! 
check_page_installed_pgdir<span class=o>()</span> succeeded!
Welcome to the JOS kernel monitor!
Type <span class=s1>&#39;help&#39;</span> <span class=k>for</span> a list of commands.
K&gt; 

</code></pre></td></tr></table></div>
</div>
</div>
</div>
</article>
<div class=related-posts>
<h2 class=related-title>相关文章：<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon related-icon"><path d="M256 8C119 8 8 119 8 256s111 248 248 248 248-111 248-248S393 8 256 8zm144 276c0 6.6-5.4 12-12 12h-92v92c0 6.6-5.4 12-12 12h-56c-6.6.0-12-5.4-12-12v-92h-92c-6.6.0-12-5.4-12-12v-56c0-6.6 5.4-12 12-12h92v-92c0-6.6 5.4-12 12-12h56c6.6.0 12 5.4 12 12v92h92c6.6.0 12 5.4 12 12v56z"/></svg></h2>
<ul class=related-list>
<li class=related-item>
<a href=/archives-604/ class=related-link>MIT6.828 | Lec6: Virtual Memory - 1</a>
</li>
<li class=related-item>
<a href=/archives-602/ class=related-link>MIT6.828 | hw5: xv6 system calls 【待填坑 dup2】</a>
</li>
<li class=related-item>
<a href=/archives-601/ class=related-link>MIT6.828 | Lec 5: Isolation mechanisms</a>
</li>
<li class=related-item>
<a href=/archives-592/ class=related-link>MIT6.828 | Lec4: Shell & OS organization</a>
</li>
<li class=related-item>
<a href=/archives-579/ class=related-link>MIT6.828 | Lab 2: Memory Management</a>
</li>
</ul>
</div>
<div class=post-tags>
<a href=/tags/note/ rel=tag class=post-tags-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon tag-icon"><path d="M0 252.118V48C0 21.49 21.49.0 48 0h204.118a48 48 0 0133.941 14.059l211.882 211.882c18.745 18.745 18.745 49.137.0 67.882L293.823 497.941c-18.745 18.745-49.137 18.745-67.882.0L14.059 286.059A48 48 0 010 252.118zM112 64c-26.51.0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48-21.49-48-48-48z"/></svg>note</a>
<a href=/tags/mit6.828/ rel=tag class=post-tags-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon tag-icon"><path d="M0 252.118V48C0 21.49 21.49.0 48 0h204.118a48 48 0 0133.941 14.059l211.882 211.882c18.745 18.745 18.745 49.137.0 67.882L293.823 497.941c-18.745 18.745-49.137 18.745-67.882.0L14.059 286.059A48 48 0 010 252.118zM112 64c-26.51.0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48-21.49-48-48-48z"/></svg>MIT6.828</a>
</div>
<footer class=minimal-footer>
<div class=post-tag><a href=/tags/note/ rel=tag class=post-tag-link>#note</a> <a href=/tags/mit6.828/ rel=tag class=post-tag-link>#mit6828</a></div>
<div class=post-category>
<a href=/tech/ class="post-category-link active">tech</a>
</div>
</footer>
<ul class=post-nav>
<li class=post-nav-prev>
<a href=/archives-588/ rel=prev>&lt; MIT6.828 | Lab 2: Memory Management - Part 3: Kernel Address Space</a>
</li>
<li class=post-nav-next>
<a href=/archives-578/ rel=next>MIT6.828 | Lab 2: Memory Management - Part 1: Physical Page Management ></a>
</li>
</ul>
</div>
</main>
<div id=back-to-top class=back-to-top>
<a href=#><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" class="icon arrow-up"><path d="M34.9 289.5l-22.2-22.2c-9.4-9.4-9.4-24.6.0-33.9L207 39c9.4-9.4 24.6-9.4 33.9.0l194.3 194.3c9.4 9.4 9.4 24.6.0 33.9L413 289.4c-9.5 9.5-25 9.3-34.3-.4L264 168.6V456c0 13.3-10.7 24-24 24h-32c-13.3.0-24-10.7-24-24V168.6L69.2 289.1c-9.3 9.8-24.8 10-34.3.4z"/></svg></a>
</div>
<footer id=footer class=footer>
<div class=footer-inner>
<div class=site-info>©&nbsp;2019–2021&nbsp;&nbsp;Jiachen</div><div class=site-copyright><a href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh target=_blank rel=noopener>CC BY-NC-SA 4.0</a></div>
</div>
</footer>
</div>
<script>'serviceWorker'in navigator&&window.addEventListener('load',function(){navigator.serviceWorker.register('/sw.js')})</script>
<script src=https://cdn.jsdelivr.net/npm/medium-zoom@latest/dist/medium-zoom.min.js></script>
<script>mediumZoom(document.querySelectorAll('div.post-body img'),{background:'hsla(var(--color-bg-h), var(--color-bg-s), var(--color-bg-l), 0.95)'})</script>
<script src=https://cdn.jsdelivr.net/npm/instant.page@5.1.0/instantpage.min.js type=module defer></script>
</body>
</html>